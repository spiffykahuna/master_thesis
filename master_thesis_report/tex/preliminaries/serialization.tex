\subsection{Data serialization}
\begin{quotation}
\textit{
Serialization is a process for converting a data structure or object into a format that
can be transmitted through a wire, or stored somewhere for later
use~\cite{json_vs_yaml}.
}
\end{quotation}
Previous sections described some possible implementations of Service Oriented
Architecture. These technologies use client-server communication and
send information between client and server, that need to be understood at both
destinations. No matter how this information is sent, using resource/object representation in case of REST or
request/response message in case of RPC, it needs to be converted to format that
can be decoded with the user of that information. Common transmission scenario
can look like:
\begin{enumerate}
  \item Client wants to send a some information to a server. It has some data in
  memory and that data is in application specific format(object structure, text,
  image, movie file).
  \item Client \textbf{packs} his information into a message and sends it to
  server using any possible transport channel(email, paper mail, homing pigeon, tcp
  socket, etc).
  \item Server receives this message, \textbf{unpacks} the message and gets a
  piece of information that client wanted to send.
  \item Server reads the information and decides what to do with it.
\end{enumerate}

Process of packing information is called \textbf{serialization} (also deflating
or marshalling) and process of unpacking is called \textbf{deserialization}
(inflating or unmarshalling). 

There are lots of different ways and formats that can
be used. Which method and format to choose depends on the requirements set up on
the object or data, and the use for the serialization (sending or storing). The choice
may also affect the size of the serialized data as well as serialization/deserialization
performance in terms of processing time and memory usage\cite{json_vs_yaml}.
Next section describes possible serialization solutions.

\subsubsection{Serialization technologies}
Serialization is supported by many programming languages, which provide tools
and libraries for data serialization to different formats. Article
\cite{wikipedia:comparison_of_data_serialization_formats}
provides a summary of well known data serialization formats.
Most of them could be divided into two groups: human-readable text based formats
and binary formats. Both groups have their own advantages and disadvantages.
\autoref{tbl:data_ser_formats} shortly describes them. 

\begin{table}[h]
	\centering	
	\begin{tabularx}{\textwidth}{|X|X|X|}
		\hline
		\textbf{Property} & 
		\textbf{Binary formats}  	& 
		\textbf{Human-readable formats}	
	    
	    \tabularnewline
		\hline
		Format examples &
		Protocol Buffers from Google \newline 
		{Apache Thrift(TBinaryProtocol)} \newline
		BSON used in MongoDB database \newline
		MessagePack(\url{http://msgpack.org})\newline
		and most of native serialization
		mechanisms in various programming languages(Java, Python, .NET framework,
		C++ BOOST serialization) &
		\gls{XML} \newline \gls{JSON} \newline \gls{YAML}
	
	    \tabularnewline
		\hline	  
		
		Advantages & 
		The two main reasons why binary formats are usually proposed
		are for \textbf{size} and \textbf{speed}. \newline
		Typically use fewer CPU cycles and requre less memory.
		Binary data is transformed as is, no need to encode data bytes( image, video,
		etc)
		Better for larger datasets \newline
		Random data access.
		

		
		&
		
		Do not have to write extra tools to debug the input and output; you can open
		the serialized output with a text editor to see if it looks right. \newline
		Self-descriptive and easily recoverable. \newline
		No need to use programming issues like sizeof and little-endian vs.
		big-endian. \newline
		Platform and programming language independent. \newline
		Broad support by tools and libraries \newline
		
		
		
		
		\tabularnewline
		\hline
		Disadvantages &
		Not verbose. Hard to debug. \newline
		Fixed data structures. Hard to extend. \newline
		Not self-descriptive( it is hard to undestand for human where actual data
		starts in the array of bytes, ), has no data description( metadata, layout
		of the data)\newline Require special software and  highly customized data
		access algorithms.
		Hard to recover data after software version change (remember different MS
		office formats)
				
		&
		
		Binary data needs to be converted to text form( Base64). \newline
		Additional processing overhead (CPU and memory consumption). \newline
		Lot of redundancy.
		Representing your data as text is not always easy/possible or
		reasonable(video/audio streams, large matrices with numbers)
				
				
		\tabularnewline
		\hline
	\end{tabularx} 
	\caption{Comparison of binary and human-readable serialization formats}
	\label{tbl:data_ser_formats}
\end{table}

Text-based nature makes human-readable format a suitable choice
for applications where humans are expected to see the data,
such as in document editing or where debugging information
is needed. Binary formats are better for high speed and low latency
applications.

\subsubsection{XML vs JSON}
Choosing the right serialization format mostly depends on your data and
application. But if there is no any constraint what protocol to use, text
protocols are more preferable. They give you advantages like: verbosity,
extensibility, portability.

Most popular human and machine readable serialization formats are XML and JSON.

\paragraph{XML} ~\\
\begin{quotation}
\textit{
XML is hugely important. Dr Charles Goldfarb, who was personally involved in its
invention, claims it to be “the holy grail of computing, solving the problem of universal data interchange between dissimilar systems.” It is also a handy format for everything from configuration files to data and documents of almost any type.
~\cite{xml_intro}}
\end{quotation} 

The fundamental design considerations of XML include
simplicity and human readability\cite{NurseitovPRI09}.
W3C\footnote{World Wide Web Consortium} specifies the design goals for XML
like~\cite{w3c_xml}:
\begin{enumerate}
  \item XML shall be straightforwardly usable over the Internet.
  \item XML shall support a wide variety of applications.
  \item XML shall be compatible with SGML\footnotemark.
  \item It shall be easy to write programs which process XML documents.
  \item The number of optional features in XML is to be kept to the absolute minimum, ideally zero.
  \item XML documents should be human-legible and reasonably clear.
  \item The XML design should be prepared quickly.
  \item The design of XML shall be formal and concise.
  \item XML documents shall be easy to create.
  \item Terseness in XML markup is of minimal importance.  
\end{enumerate}
\footnotetext{Standard Generalized Markup Language. SGML is a system for
defining markup languages. Authors mark up their documents by representing
structural, presentational, and semantic information alongside
content.~\cite{html_spec}}

The primary uses for XML are Remote Procedure Calls and object serialization for transfer of
data between applications. 

Simple data structure in XML looks like:

\begin{listing}[H]
\begin{minted}[frame=lines,
               framesep=2mm]{xml}
<person>
	<firstname>John</firstname>
	<surname>Smith</surname>
	<email>john.smith@example.com</email>
	<mobile>1234567890</mobile>
</person>
\end{minted}
\caption{XML structure decribing abstract person}
\label{lst:xml_person_example}
\end{listing}


\paragraph{JSON} ~\\
JSON (JavaScript Object Notation) is a lightweight data-interchange
format\cite{json_org}.It is easy for humans to read and write and also is
easy for machines to parse and generate. JSON is based on JavaScript
Programming Language and is directly supported inside JavaScript. It has library
bindings for popular programming languages.

JSON is built on two structures\cite{json_org}:
\begin{itemize}
  \item A collection of name/value pairs. In various languages, this is realized
  as an object, record, struct, dictionary, hash table, keyed list, or associative array.
  \item An ordered list of values. In most languages, this is realized as an
  array, vector, list, or sequence.
\end{itemize}

The same sturucture from XML section looks in JSON encoding like:
\begin{listing}[H]
\begin{minted}[frame=lines,
               framesep=2mm]{json}
{
	"firstname" : "John",
	"surname" : "Smith",
	"email" : "john.smith@example.com",
	"mobile" : 1234567890
}
\end{minted}
\caption{JSON structure decribing abstract person}
\label{lst:json_person_example}
\end{listing}

JSON value can be a string in double quotes, or a number, or true or false or
null, or an object or an array. These structures can be nested.

JSON specification is quite easy and it is  described using only one
page~\cite{json_org}. This page provides also a list of programming languages
and libraries that support JSON. 

TODO HERE comes comparison.    


